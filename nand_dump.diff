diff --git a/src/uarm/nand.c b/src/uarm/nand.c
index 9760e9b..9a12e71 100644
--- a/src/uarm/nand.c
+++ b/src/uarm/nand.c
@@ -55,6 +55,8 @@ struct NAND {
     uint8_t *data;  // stores inverted data (so 0-init is valid)
 };
 
+static struct NAND *gNand = NULL;
+
 void nandSecondReadyCbkSet(struct NAND *nand, NandReadyCbk readyCbk, void *readyCbkData) {
     nand->readyCbk[1] = readyCbk;
     nand->readyCbkData[1] = readyCbkData;
@@ -120,8 +122,8 @@ static bool nandPrvPageProgram(struct NAND *nand) {
         nand->data[nand->pageNo * nand->bytesPerPage + i] &= nand->pageBuf[i];
         //	if (nand->data[nand->pageNo * NAND_PAGE_SIZE + i] != nand->pageBuf[i])
         //		fprintf(stderr, "write fail for page %u af ofst %u. wrote 0x%02x, read
-        //0x%02x\n", nand->pageNo, i, nand->pageBuf[i], nand->data[nand->pageNo * NAND_PAGE_SIZE +
-        //i]);
+        // 0x%02x\n", nand->pageNo, i, nand->pageBuf[i], nand->data[nand->pageNo * NAND_PAGE_SIZE +
+        // i]);
     }
 
     return true;
@@ -331,7 +333,7 @@ bool nandRead(struct NAND *nand, bool cle, bool ale, uint8_t *valP) {
 
                 // fprintf(stderr, "reading page %5u (block addr %4u.%2u) area %c offset %u\n",
                 //	nand->pageNo, nand->pageNo / NAND_PAGES_PER_BLOCK, nand->pageNo %
-                //NAND_PAGES_PER_BLOCK, 'A' + (unsigned)nand->area, nand->addr[0]);
+                // NAND_PAGES_PER_BLOCK, 'A' + (unsigned)nand->area, nand->addr[0]);
 
                 if (nand->pageNo >= (nand->blocksPerDevice << nand->pagesPerBlockLg2)) {
                     fprintf(stderr, "page number ouf of bounds\n");
@@ -380,11 +382,25 @@ void nandPeriodic(struct NAND *nand) {
     if (nand->busyCt && !--nand->busyCt) nandPrvCallReadyCbks(nand, true);
 }
 
+void nandDump() {
+    if (!gNand) return;
+
+    FILE *file = fopen("nand_dump.bin", "w");
+
+    const uint32_t nandPages = gNand->blocksPerDevice << gNand->pagesPerBlockLg2;
+    const uint32_t nandSz = gNand->bytesPerPage * nandPages;
+
+    fwrite(gNand->data, nandSz, 1, file);
+    fclose(file);
+}
+
 bool nandIsReady(struct NAND *nand) { return !nand->busyCt; }
 
 struct NAND *nandInit(FILE *nandFile, const struct NandSpecs *specs, NandReadyCbk readyCbk,
                       void *readyCbkData) {
     struct NAND *nand = (struct NAND *)malloc(sizeof(*nand));
+    gNand = nand;
+
     uint32_t nandSz, nandPages, t;
 
     if (!nand) ERR("cannot alloc NAND");
diff --git a/src/uarm/nand.h b/src/uarm/nand.h
index fe7afe2..d68bb9f 100644
--- a/src/uarm/nand.h
+++ b/src/uarm/nand.h
@@ -43,6 +43,8 @@ bool nandIsReady(struct NAND *nand);
 
 void nandPeriodic(struct NAND *nand);
 
+void nandDump();
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/uarm/pxa_PwrClk.c b/src/uarm/pxa_PwrClk.c
index fcea5c2..97ea8f9 100644
--- a/src/uarm/pxa_PwrClk.c
+++ b/src/uarm/pxa_PwrClk.c
@@ -5,6 +5,7 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include "nand.h"
 #include "util.h"
 
 #define PXA_CLOCK_MANAGER_BASE 0x41300000UL
@@ -65,6 +66,7 @@ static bool pxaPwrClkPrvCoproc14regXferFunc(struct ArmCpu *cpu, void *userData,
                     fprintf(stderr,
                             "Someone tried to set processor power mode (cp14 reg7) to 0x%08lx\n",
                             (unsigned long)val);
+                    nandDump();
                 }
                 goto success;
 
